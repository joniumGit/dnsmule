$id: /dnsmule/rules
type: object
title: DNSMule rule definition
description: |+2
  This file is used to define rules and configuration for DNSMule

  The general rule resolution flow goes as follows:
  - Create factory type rules without parameters
  - Create other rules from definition file
  - Gather data
  - Create factory type rules with Record parameter
  - Run data through the rules
required:
  - version
  - rules
properties:
  version:
    type: string
    pattern: ^\d+(?:\.\d+){0,2}$
  rules:
    $ref: '#/definitions/rules'
definitions:
  rules:
    type: array
    uniqueItems: true
    items:
      anyOf:
        - $ref: "#/definitions/rule"
        - $ref: "#/definitions/dns.regex"
        - $ref: "#/definitions/dns.dynamic"
  rule:
    type: object
    additionalProperties: true
    title: DNSMule rule
    description:
      Any additional properties are passed to the respective rule type factory to produce the rule instance.
      See the concrete subtypes for parameters.
    required:
      - type
      - record
    properties:
      type:
        type: string
        pattern: ^\w+(?:\.\w++)$
        title: DNSMule module for rule creation
      record:
        type: string
        pattern: ^\w+$|^\*$
        title: DNS Record type for this rule
        description:
          See the full IANA list of record types
          https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
      priority:
        type: integer
        minimum: 0
        default: 0
        title: Rule priority
  dns.regex.base:
    title: Matches DNS records with regex
    allOf:
      - $ref: "/#definitions/rule"
      - type: object
        additionalProperties: true
        required:
          - pattern
        properties:
          type:
            type: string
            const: dns.regex
            title: Matches DNS records with regex
          flags:
            type: array
            default: [ ]
            items:
              type: string
              title: Python RegExp flags
          attribute:
            type: string
            default: to_text
            title: DNS Record attribute to use for regex match
            description: |
              This can be used to used an alternative attribute for regex match instead of to_text.
              Alternatives can be checked from dnspython docs for response record types.
        oneOf:
          - type: object
            properties:
              pattern:
                type: string
                title: Python style regex for specifying the match
                description:
                  The regex can contain one capture group for capturing the identification property.
                  In this case the group property has to be specified. Otherwise identification is used.
                x-intellij-language-injection: PythonRegExp
          - type: object
            properties:
              patterns:
                type: array
                items:
                  type: string
                  title: Python style regular expressions for specifying the match
                  description:
                    The regex can contain one capture group for capturing the identification property.
                    In this case the group property has to be specified. Otherwise identification is used.
                  x-intellij-language-injection: PythonRegExp
  dns.regex:
    oneOf:
      - type: object
        additionalProperties: false
        allOf:
          - $ref: '#/definitions/dns.regex.base'
          - type: object
            required:
              - identification
            properties:
              identification:
                type: string
                pattern: ^\w+$
                title: Service identification tag
                description:
                  This will be appended to the end as DNS::REGEX::identification.upper()
      - type: object
        additionalProperties: false
        allOf:
          - $ref: '#/definitions/dns.regex.base'
          - type: object
            required:
              - group
            properties:
              group:
                type:
                  - integer
                  - string
                minimum: 1
                minLength: 1
                title: Service identification tag
                description:
                  This will be appended to the end as DNS::REGEX::mathc.group(group).upper()
  dns.dynamic:
    allOf:
      - $ref: '#/definitions/rule'
      - type: object
        title: Complex Factory for Rules
        required:
          - code
        properties:
          type:
            type: string
            const: dns.dynamic
          code:
            type: string
            title: Creates rules by invoking python code
            description: |+2
              It is possible to define dynamic rules with two methods:
            
              As a plain factory for dynamically creating rules:
            
                def initialize() -> None:
                    add_rule(Type.TXT, ...)
            
              As a normal rule which is evaluated dynamically:
            
                def process(record) -> Optional[Result]:
                    add_rule(...)
                    return record.result()
            
              The only globals passed to these functions are objects available from:
              - __builtins__
              - from typing import List, Callable, Optional
              - from .data import Type, Record, Result
              - from .types import RULE_TYPE as Rule
              - add_rule, see below
            
              When the code is evaluated the result is inspected for:
              - initialize function without parameters
              - process function with a single parameter
            
              It is possible to set globals in the initialize function as the context persists between calls.
            
              Some notes:
              - The initialize function is invoked exactly once.
              - The process function is invoked exactly once for every single Record.
              - The rules returned from the initialize will be invoked for every suitable record.
              - The rules returned from the process will be invoked for every suitable record after adding it.
              - It is not guaranteed that recursion works if a new dynamic rule is added
            x-intellij-language-injection:
              language: Python
              prefix: |+0
                from typing import List, Callable, Optional

                from dnsmule.rules.data import Type, Record, Result
                from dnsmule.rules.types import RULE_TYPE as Rule
                
                def add_rule(record: Type, rule_type: str, priority: int = 0, **options):
                    pass

              suffix: ''